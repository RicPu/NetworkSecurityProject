\section{Results}
In this section, we summarize the performance measurements and packet-level analysis obtained through the benchmarking routines and PyShark captures. \\
The performance of both implementations is evaluated in terms of:

\begin{itemize}
    \item \textbf{Latency Metrics:} Handshake time and Round-Trip Time (RTT), including standard deviation.
    
    \item \textbf{Transfer Metrics:} Upload and download times, and calculated throughput (in MB/s).
\end{itemize}

Both the TCP+TLS and QUIC clients incorporate dedicated modules to aggregate these metrics (e.g., via the \texttt{BenchmarkStats} class) and present the results in formatted tables using the \texttt{tabulate} library.

\subsection{Summary of Results}
The following table summarize the average benchmark metrics obtained for each protocol. The numbers refer to the average time passed for 5 ping requests, 3 uploads and 3 downloads of a file of custom size that can be created by the user (in this case, the results refer to a file of 1GB size).

\begin{table}[h!]
\centering
\begin{tabular}{lcc}
\toprule
\textbf{Metric} & \textbf{TCP+TLS} & \textbf{QUIC} \\
\midrule
Handshake Time & 0.006017 s & 0.019117 s \\
Average RTT & 0.000950 s & 0.005623 s \\
RTT Std. Dev. & 0.000492 s & 0.003769 s \\
Average Upload Time & 4.422592 s & 890.674859 s \\
Average Upload Throughput & 246.68 MB/s & 1.15 MB/s \\
Average Download Time & 4.284258 s & 885.309263 s \\
Average Download Throughput & 254.56 MB/s & 1.16 MB/s \\
\bottomrule
\end{tabular}
\caption{Comparison of network performance metrics between TCP+TLS and QUIC.}
\end{table}

These metrics provide a detailed comparison of TCP+TLS and QUIC in terms of connection setup, latency, and data transfer performance. Handshake Time represents the time taken to establish a secure connection, which directly affects how quickly a session can begin. A lower handshake time is preferable, especially for applications requiring fast setup, such as real-time communications. Average RTT (Round-Trip Time) measures the time it takes for a packet to travel to its destination and back, serving as an indicator of network responsiveness. A lower RTT suggests better performance, particularly for latency-sensitive applications like video calls or online gaming. RTT Standard Deviation quantifies the variability in RTT, providing insight into network stability; high variability can lead to inconsistent performance and jitter. Average Upload and Download Time indicate how long it takes to transfer data in either direction, which is critical for evaluating protocol efficiency under different network conditions. Average Upload and Download Throughput measure the rate at which data is successfully transmitted, with higher values indicating more efficient use of available bandwidth.

\subsection{Detailed Results}
The following tables present the download and upload performance for both TCP+TLS and QUIC, focusing on two key metrics: transfer time and throughput. Transfer time indicates how long it takes to complete the data transfer, while throughput measures the rate at which data is successfully transmitted. Lower transfer times and higher throughput values suggest better performance. Each test was repeated three times to ensure accuracy and minimize the impact of network fluctuations. The results for upload performance are presented first, followed by download performance.

\paragraph{Upload Results.} We tested the upload performance over a 1GB test file (\texttt{test\_upload.bin}), which was generated by the code itself. The results below show the download time and throughput for both TCP+TLS and QUIC across three iterations.

\begin{table}[!h]
\centering
\begin{tabular}{ccccc}
\toprule
\textbf{Iteration} & \multicolumn{2}{c}{\textbf{TCP + TLS}} & \multicolumn{2}{c}{\textbf{QUIC}} \\
& Time (s) & Throughput (MB/s) & Time (s) & Throughput (MB/s) \\
\midrule
1 & 3.582199 & 285.86 & 894.224662 & 1.15 \\
2 & 3.571778 & 286.69 & 889.082609 & 1.15 \\
3 & 6.113801 & 167.49 & 888.717308 & 1.15 \\
\bottomrule
\end{tabular}
\caption{Performance comparison of upload time and throughput between TCP+TLS and QUIC across three iterations.}
\end{table}

\paragraph{Download Results.} For the upload test, we followed a similar approach, using a 1GB test file (\texttt{test\_download.bin}) generated by the code itself. The table below shows the upload time and throughput for both TCP+TLS and QUIC across three iterations.

\begin{table}[!h]
\centering
\begin{tabular}{ccccc}
\toprule
\textbf{Iteration} & \multicolumn{2}{c}{\textbf{TCP + TLS}} & \multicolumn{2}{c}{\textbf{QUIC}} \\
& Time (s) & Throughput (MB/s) & Time (s) & Throughput (MB/s) \\
\midrule
1 & 5.917546 & 173.04 & 887.140160 & 1.15 \\
2 & 3.449762 & 296.83 & 885.737737 & 1.16 \\
3 & 3.485467 & 293.79 & 883.049894 & 1.16 \\
\bottomrule
\end{tabular}
\caption{Performance comparison of download time and throughput between TCP+TLS and QUIC across three iterations.}
\end{table}

\noindent In both protocols, each iteration of download and upload resulted in a slight variations in transfer time and throughput across iterations. As can be clearly seen, QUIC implementation showed significantly higher transfer times and much lower throughput compared to the TCP+TLS implementation, which is attributed to a bottleneck somewhere in the server implementation, probably due to the fact that the implementation of the QUIC protocol in Python is still immature.

\subsection{PyShark-based Traffic Analysis}
For both protocols, PyShark was used to:
\begin{itemize}
    \item Verify the sequence of handshake messages.
    \item Monitor the data transfer phases.
    \item Detect anomalies such as retransmissions or unexpected protocol behavior.
\end{itemize}
Separate captures were configured for TCP+TLS (filtering on \texttt{tcp.port == 8443}) and for QUIC (filtering on \texttt{udp.port == 4433}). The results provide a complementary view to the numerical performance metrics.
\newline

\textbf{TCP+TLS PyShark Observations:}
\begin{itemize}
    \item Ping operations captured 2 packets.
    \item File transfer operations (upload/download) captured approximately 98 packets, confirming the expected segmentation and sequence. Possibly due to the implementation, the packet captured were always 2 short of the number of packets set.
\end{itemize}

\textbf{QUIC PyShark Observations:}
\begin{itemize}
    \item Ping operations captured 4 packets.
    \item Upload and download operations captured 100 packets each, with packet labels indicating encrypted QUIC DATA frames.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{images/PysharkQUIC.png}
	\caption{Example of QUIC packets captured using PyShark.}
\end{figure}

\noindent \textbf{Results and Discussion} \newline
The aggregated results from the benchmarking tests and the packet-level analysis highlight:
\begin{itemize}
    \item \textbf{TCP+TLS:}  
    \begin{itemize}        
        \item The TCP+TLS captures confirm efficient segmentation and a proper sequence of TLS handshakes.
        \item The QUIC captures validate the operation of multiplexed streams and consistent encryption (DATA frames), although the overall performance is lower.
    \end{itemize}
\end{itemize}